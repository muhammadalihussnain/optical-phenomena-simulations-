<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prism Effect & Snell's Law</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0a0a1a, #1a1a3e);
            font-family: 'Arial', sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: #ff6b9d;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ff6b9d;
        }
        
        .subtitle {
            color: #888;
            text-align: center;
            margin-bottom: 30px;
        }
        
        canvas {
            border: 2px solid #ff6b9d;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 107, 157, 0.3);
            background: #000011;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b9d, #ff8fb3);
            border: none;
            color: #000;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 157, 0.4);
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 25px;
            border: 1px solid #ff6b9d;
        }
        
        .slider {
            width: 150px;
            height: 5px;
            border-radius: 5px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ff6b9d;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 157, 0.5);
        }
        
        .info-panel {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 1000px;
        }
        
        .info-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #444;
            text-align: center;
        }
        
        .info-box h3 {
            color: #ff6b9d;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        .value {
            color: #00ffff;
            font-weight: bold;
            font-size: 16px;
        }
        
        .physics-explanation {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #ff6b9d;
            max-width: 900px;
            text-align: center;
        }
        
        .formula {
            font-size: 18px;
            color: #ffff88;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <h1>Prism Effect & Snell's Law Demonstration</h1>
    <p class="subtitle">Watch light refraction through a triangular prism with dispersion effects</p>
    
    <canvas id="prismCanvas" width="1000" height="700"></canvas>
    
    <div class="controls">
        <button onclick="toggleAnimation()">Pause/Resume</button>
        <button onclick="resetAnimation()">Reset</button>
        <div class="slider-container">
            <label>Refractive Index:</label>
            <input type="range" min="1.3" max="2.0" step="0.05" value="1.5" class="slider" id="refractiveSlider" oninput="updateRefractiveIndex(this.value)">
            <span id="refractiveValue">1.5</span>
        </div>
        <div class="slider-container">
            <label>Incident Angle:</label>
            <input type="range" min="10" max="80" step="5" value="45" class="slider" id="angleSlider" oninput="updateIncidentAngle(this.value)">
            <span id="angleValue">45°</span>
        </div>
        <button onclick="toggleDispersion()">Toggle Dispersion</button>
    </div>
    
    <div class="info-panel">
        <div class="info-box">
            <h3>Refractive Index</h3>
            <div class="value" id="nValue">1.5</div>
        </div>
        <div class="info-box">
            <h3>Incident Angle</h3>
            <div class="value" id="incidentValue">45°</div>
        </div>
        <div class="info-box">
            <h3>Refraction Angle</h3>
            <div class="value" id="refractionValue">28.1°</div>
        </div>
        <div class="info-box">
            <h3>Critical Angle</h3>
            <div class="value" id="criticalValue">41.8°</div>
        </div>
        <div class="info-box">
            <h3>Deviation Angle</h3>
            <div class="value" id="deviationValue">16.9°</div>
        </div>
        <div class="info-box">
            <h3>Dispersion</h3>
            <div class="value" id="dispersionValue">OFF</div>
        </div>
    </div>
    
    <div class="physics-explanation">
        <h3 style="color: #ff6b9d;">Snell's Law & Prism Physics</h3>
        <div class="formula">n₁ sin(θ₁) = n₂ sin(θ₂)</div>
        <p>Light bends when entering a denser medium. The prism demonstrates refraction at two surfaces.</p>
        <p><strong>Dispersion:</strong> Different wavelengths (colors) have slightly different refractive indices, causing separation.</p>
        <div class="formula">δ = θ₁ + θ₂ - A (Deviation Formula)</div>
    </div>

    <script>
        const canvas = document.getElementById('prismCanvas');
        const ctx = canvas.getContext('2d');
        
        let animationId;
        let time = 0;
        let isAnimating = true;
        let refractiveIndex = 1.5;
        let incidentAngle = 45; // degrees
        let showDispersion = false;
        
        // Light ray arrays
        let incidentRays = [];
        let refractedRays = [];
        let emergentRays = [];
        let reflectedRays = [];
        
        // Prism geometry
        const prismX = 500;
        const prismY = 350;
        const prismSize = 120;
        const prismAngle = 60; // degrees (equilateral triangle)
        
        // Laser position (perpendicular setup)
        const laserX = 200;
        const laserY = 350;
        
        // Colors for dispersion
        const colors = [
            { name: 'Red', wavelength: 700, n: 0, color: [255, 100, 100] },
            { name: 'Orange', wavelength: 620, n: 0, color: [255, 165, 100] },
            { name: 'Yellow', wavelength: 580, n: 0, color: [255, 255, 100] },
            { name: 'Green', wavelength: 530, n: 0, color: [100, 255, 100] },
            { name: 'Blue', wavelength: 470, n: 0, color: [100, 150, 255] },
            { name: 'Violet', wavelength: 420, n: 0, color: [150, 100, 255] }
        ];
        
        function updateDispersionIndices() {
            // Cauchy's equation approximation for dispersion
            const B = 0.01; // Dispersion parameter
            colors.forEach(color => {
                const lambda = color.wavelength / 1000; // Convert to micrometers
                color.n = refractiveIndex + B / (lambda * lambda);
            });
        }
        
        function updateRefractiveIndex(value) {
            refractiveIndex = parseFloat(value);
            document.getElementById('refractiveValue').textContent = value;
            updateDispersionIndices();
            updateUI();
        }
        
        function updateIncidentAngle(value) {
            incidentAngle = parseInt(value);
            document.getElementById('angleValue').textContent = value + '°';
            updateUI();
        }
        
        function toggleDispersion() {
            showDispersion = !showDispersion;
            document.getElementById('dispersionValue').textContent = showDispersion ? 'ON' : 'OFF';
        }
        
        function calculateSnellsLaw(n1, n2, theta1Deg) {
            const theta1Rad = (theta1Deg * Math.PI) / 180;
            const sinTheta2 = (n1 / n2) * Math.sin(theta1Rad);
            
            if (sinTheta2 > 1) {
                return null; // Total internal reflection
            }
            
            const theta2Rad = Math.asin(sinTheta2);
            return (theta2Rad * 180) / Math.PI;
        }
        
        function drawBackground() {
            // Clear canvas with gradient
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, 'rgba(0, 30, 60, 0.9)');
            gradient.addColorStop(1, 'rgba(0, 8, 24, 1)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add reference grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function drawLaser() {
            // Laser housing (perpendicular to prism)
            ctx.fillStyle = '#444';
            ctx.fillRect(laserX - 40, laserY - 20, 80, 40);
            
            // Laser aperture
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(laserX + 35, laserY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Calculate beam path to prism (perpendicular setup)
            const beamEndX = prismX - prismSize/2;
            const beamEndY = laserY;
            
            // Main laser beam
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(laserX + 40, laserY);
            ctx.lineTo(beamEndX, beamEndY);
            ctx.stroke();
            
            // Beam glow
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 12;
            ctx.beginPath();
            ctx.moveTo(laserX + 40, laserY);
            ctx.lineTo(beamEndX, beamEndY);
            ctx.stroke();
            
            // Label
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#ff6b9d';
            ctx.fillText('White Light Source', laserX - 40, laserY - 35);
        }
        
        function drawPrism() {
            // Calculate prism vertices (equilateral triangle)
            const vertices = [
                { x: prismX - prismSize/2, y: prismY + prismSize * Math.sin(Math.PI/3) / 2 },
                { x: prismX + prismSize/2, y: prismY + prismSize * Math.sin(Math.PI/3) / 2 },
                { x: prismX, y: prismY - prismSize * Math.sin(Math.PI/3) / 2 }
            ];
            
            // Prism body with glass effect
            const gradient = ctx.createLinearGradient(prismX - prismSize/2, prismY, prismX + prismSize/2, prismY);
            gradient.addColorStop(0, `rgba(150, 200, 255, 0.3)`);
            gradient.addColorStop(0.5, `rgba(200, 230, 255, 0.4)`);
            gradient.addColorStop(1, `rgba(150, 200, 255, 0.3)`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(vertices[2].x, vertices[2].y);
            ctx.closePath();
            ctx.fill();
            
            // Prism edges
            ctx.strokeStyle = 'rgba(200, 230, 255, 0.8)';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Refractive index indicator
            ctx.fillStyle = `rgba(255, 255, 255, ${refractiveIndex * 0.2})`;
            ctx.fill();
            
            // Normal lines at surfaces
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            
            // Left surface normal
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y - 50);
            ctx.lineTo(vertices[0].x, vertices[0].y + 50);
            ctx.stroke();
            
            // Right surface normal
            const rightNormalAngle = Math.PI/3; // 60 degrees
            const normalLength = 50;
            ctx.beginPath();
            ctx.moveTo(vertices[1].x - Math.cos(rightNormalAngle) * normalLength, 
                      vertices[1].y - Math.sin(rightNormalAngle) * normalLength);
            ctx.lineTo(vertices[1].x + Math.cos(rightNormalAngle) * normalLength, 
                      vertices[1].y + Math.sin(rightNormalAngle) * normalLength);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Labels
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#ff6b9d';
            ctx.fillText('Triangular Prism', prismX - 50, prismY - 80);
            
            ctx.font = '14px Arial';
            ctx.fillStyle = '#ffff88';
            ctx.fillText(`n = ${refractiveIndex}`, prismX - 20, prismY + 10);
            ctx.fillText(`A = ${prismAngle}°`, prismX - 20, prismY + 30);
        }
        
        function generatePhotons() {
            if (Math.random() < 0.2) {
                if (showDispersion) {
                    // Generate photons for each color
                    colors.forEach((color, index) => {
                        if (Math.random() < 0.3) {
                            incidentRays.push({
                                x: laserX + 40,
                                y: laserY + (Math.random() - 0.5) * 10,
                                vx: 3,
                                vy: 0,
                                color: color.color,
                                refractiveIndex: color.n,
                                wavelength: color.wavelength,
                                energy: 1.0,
                                alpha: 0.8,
                                size: 2 + Math.random() * 2
                            });
                        }
                    });
                } else {
                    // White light photon
                    incidentRays.push({
                        x: laserX + 40,
                        y: laserY + (Math.random() - 0.5) * 10,
                        vx: 3,
                        vy: 0,
                        color: [255, 255, 255],
                        refractiveIndex: refractiveIndex,
                        wavelength: 550, // Green (middle of spectrum)
                        energy: 1.0,
                        alpha: 0.9,
                        size: 3 + Math.random() * 2
                    });
                }
            }
        }
        
        function updatePhotons() {
            // Update incident photons
            for (let i = incidentRays.length - 1; i >= 0; i--) {
                const photon = incidentRays[i];
                photon.x += photon.vx;
                photon.y += photon.vy;
                
                // Check collision with prism left surface
                const prismLeftX = prismX - prismSize/2;
                if (photon.x >= prismLeftX - 5 && photon.x <= prismLeftX + 5 && 
                    Math.abs(photon.y - prismY) < prismSize/2) {
                    
                    // Calculate refraction at first surface
                    const theta1 = incidentAngle;
                    const theta2 = calculateSnellsLaw(1.0, photon.refractiveIndex, theta1);
                    
                    if (theta2 !== null) {
                        // Refracted ray inside prism
                        const theta2Rad = (theta2 * Math.PI) / 180;
                        const speed = 2.5; // Slower in medium
                        
                        refractedRays.push({
                            x: photon.x,
                            y: photon.y,
                            vx: Math.cos(theta2Rad) * speed,
                            vy: Math.sin(theta2Rad) * speed * (photon.y > prismY ? 1 : -1),
                            color: photon.color,
                            refractiveIndex: photon.refractiveIndex,
                            wavelength: photon.wavelength,
                            energy: photon.energy * 0.9,
                            alpha: photon.alpha * 0.9,
                            size: photon.size,
                            life: 100
                        });
                    } else {
                        // Total internal reflection
                        reflectedRays.push({
                            x: photon.x,
                            y: photon.y,
                            vx: -photon.vx,
                            vy: photon.vy,
                            color: photon.color,
                            energy: photon.energy * 0.95,
                            alpha: photon.alpha,
                            size: photon.size,
                            life: 60
                        });
                    }
                    
                    incidentRays.splice(i, 1);
                } else if (photon.x > canvas.width) {
                    incidentRays.splice(i, 1);
                }
            }
            
            // Update refracted photons (inside prism)
            for (let i = refractedRays.length - 1; i >= 0; i--) {
                const photon = refractedRays[i];
                photon.x += photon.vx;
                photon.y += photon.vy;
                photon.life--;
                
                // Check collision with prism right surface
                const prismRightX = prismX + prismSize/2;
                const rightSurfaceY = prismY + (photon.x - prismX) * Math.tan(Math.PI/3);
                
                if (photon.x >= prismRightX - 10 && 
                    Math.abs(photon.y - rightSurfaceY) < 15) {
                    
                    // Calculate emergence angle
                    const internalAngle = Math.atan2(photon.vy, photon.vx) * 180 / Math.PI;
                    const surfaceAngle = 60; // Right surface angle
                    const relativeAngle = Math.abs(internalAngle - surfaceAngle);
                    
                    const emergenceAngle = calculateSnellsLaw(photon.refractiveIndex, 1.0, relativeAngle);
                    
                    if (emergenceAngle !== null) {
                        // Emergent ray
                        const emergenceRad = (emergenceAngle * Math.PI) / 180;
                        const speed = 3.5;
                        
                        emergentRays.push({
                            x: photon.x,
                            y: photon.y,
                            vx: Math.cos(emergenceRad) * speed,
                            vy: Math.sin(emergenceRad) * speed * (photon.vy > 0 ? 1 : -1),
                            color: photon.color,
                            wavelength: photon.wavelength,
                            energy: photon.energy * 0.85,
                            alpha: photon.alpha,
                            size: photon.size,
                            life: 80,
                            deviation: emergenceAngle - incidentAngle
                        });
                    }
                    
                    refractedRays.splice(i, 1);
                } else if (photon.life <= 0) {
                    refractedRays.splice(i, 1);
                }
            }
            
            // Update emergent photons
            for (let i = emergentRays.length - 1; i >= 0; i--) {
                const photon = emergentRays[i];
                photon.x += photon.vx;
                photon.y += photon.vy;
                photon.life--;
                photon.alpha *= 0.995;
                
                if (photon.life <= 0 || photon.alpha < 0.1 || 
                    photon.x > canvas.width || photon.y < 0 || photon.y > canvas.height) {
                    emergentRays.splice(i, 1);
                }
            }
            
            // Update reflected photons
            for (let i = reflectedRays.length - 1; i >= 0; i--) {
                const photon = reflectedRays[i];
                photon.x += photon.vx;
                photon.y += photon.vy;
                photon.life--;
                photon.alpha *= 0.98;
                
                if (photon.life <= 0 || photon.alpha < 0.1 || photon.x < 0) {
                    reflectedRays.splice(i, 1);
                }
            }
        }
        
        function drawPhotons() {
            // Draw all photon types
            [incidentRays, refractedRays, emergentRays, reflectedRays].forEach(rayArray => {
                rayArray.forEach(photon => {
                    const [r, g, b] = photon.color;
                    const glowSize = photon.size * 2;
                    
                    // Photon glow
                    const gradient = ctx.createRadialGradient(photon.x, photon.y, 0, photon.x, photon.y, glowSize);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${photon.alpha})`);
                    gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${photon.alpha * 0.6})`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(photon.x, photon.y, glowSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Photon core
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${photon.alpha})`;
                    ctx.beginPath();
                    ctx.arc(photon.x, photon.y, photon.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            });
        }
        
        function drawAngles() {
            // Draw angle indicators
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
            ctx.lineWidth = 2;
            
            // Incident angle arc
            const arcRadius = 40;
            const incidentRad = (incidentAngle * Math.PI) / 180;
            
            ctx.beginPath();
            ctx.arc(prismX - prismSize/2, prismY, arcRadius, -incidentRad, 0);
            ctx.stroke();
            
            // Angle labels
            ctx.font = '14px Arial';
            ctx.fillStyle = '#ffff88';
            ctx.fillText(`θ₁ = ${incidentAngle}°`, prismX - prismSize/2 - 60, prismY - 20);
            
            // Calculate and show refraction angle
            const refractionAngle = calculateSnellsLaw(1.0, refractiveIndex, incidentAngle);
            if (refractionAngle !== null) {
                const refractionRad = (refractionAngle * Math.PI) / 180;
                ctx.beginPath();
                ctx.arc(prismX - prismSize/2, prismY, arcRadius * 0.7, 0, refractionRad);
                ctx.stroke();
                
                ctx.fillText(`θ₂ = ${refractionAngle.toFixed(1)}°`, prismX - prismSize/2 + 20, prismY + 20);
            }
        }
        
        function drawSpectrum() {
            if (!showDispersion) return;
            
            // Draw spectrum on the right side
            const spectrumX = 800;
            const spectrumY = 200;
            const spectrumHeight = 300;
            
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#ff6b9d';
            ctx.fillText('Dispersed Spectrum', spectrumX - 50, spectrumY - 20);
            
            // Draw color bands
            colors.forEach((color, index) => {
                const [r, g, b] = color.color;
                const y = spectrumY + (index * spectrumHeight / colors.length);
                const height = spectrumHeight / colors.length;
                
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                ctx.fillRect(spectrumX, y, 30, height);
                
                // Color labels
                ctx.font = '12px Arial';
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 1)`;
                ctx.fillText(color.name, spectrumX + 40, y + height/2);
                ctx.fillText(`n=${color.n.toFixed(3)}`, spectrumX + 40, y + height/2 + 15);
            });
        }
        
        function updateUI() {
            document.getElementById('nValue').textContent = refractiveIndex.toFixed(2);
            document.getElementById('incidentValue').textContent = incidentAngle + '°';
            
            const refractionAngle = calculateSnellsLaw(1.0, refractiveIndex, incidentAngle);
            document.getElementById('refractionValue').textContent = 
                refractionAngle ? refractionAngle.toFixed(1) + '°' : 'TIR';
            
            const criticalAngle = Math.asin(1.0 / refractiveIndex) * 180 / Math.PI;
            document.getElementById('criticalValue').textContent = criticalAngle.toFixed(1) + '°';
            
            if (refractionAngle) {
                const deviation = incidentAngle + refractionAngle - prismAngle;
                document.getElementById('deviationValue').textContent = Math.abs(deviation).toFixed(1) + '°';
            } else {
                document.getElementById('deviationValue').textContent = 'N/A';
            }
        }
        
        function animate() {
            if (!isAnimating) return;
            
            drawBackground();
            drawLaser();
            drawPrism();
            drawAngles();
            drawSpectrum();
            
            generatePhotons();
            updatePhotons();
            drawPhotons();
            
            time += 1;
            animationId = requestAnimationFrame(animate);
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            if (isAnimating) animate();
        }
        
        function resetAnimation() {
            time = 0;
            incidentRays = [];
            refractedRays = [];
            emergentRays = [];
            reflectedRays = [];
        }
        
        // Initialize
        updateDispersionIndices();
        updateUI();
        animate();
    </script>
</body>
</html>